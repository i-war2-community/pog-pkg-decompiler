//
// (c) 2001 Particle Systems Ltd. All Rights Reserved
//
// package LocationFinder
//
// This package adds a Location Finder screen to the game.
//
// Written by Stephen Robertson
// October 2001
// 
//
// Revision control information:
//
// $Header: /iwar2/resource/scripts/src/mods/location_finder.pog 6     17/10/01 13:46 Steve $
//


// Package name ///////////////////////////////////////////////////////////////

package LocationFinder;

// Imports ////////////////////////////////////////////////////////////////////
// these are the packages we're going to use
 

uses	Sim,
		iAI,
		iShip,
		iSim,
		Debug,
		Global,
		GUI,
		iDirector,
		iFaction,
		iGame,
		iGUI,
		iHUD,
		iHabitat,
		iLagrangePoint,
		iMapEntity,
		iMultiplay,
		INIFile,
		Input,
		List,
		Object,
		Set,
		String,
		Task,
		Text,
		iUtilities;

// Exports ////////////////////////////////////////////////////////////////////
// these are the functions that are going to be called from other packages
// n.b. these start with uppercase letters, no underscores

provides Initialise,
		 LocationFinderToggle,
		 LocationFinderScreen,
		 OnSelectSystem,
		 OnSelectLocation,
		 OnQuit,
		 OnSetWaypoint,
		 OnClearWaypoint,
		 OnPDA;

// Local types ////////////////////////////////////////////////////////////////


// Local functions ////////////////////////////////////////////////////////////
// these are definitions of local calls found under the main routine

// Initialises the globals and key bindings. This must be called
// from somewhere to enable the screen.
prototype Initialise();

// Create and display the location finder screen.
prototype LocationFinderScreen();

// Turn the location finder screen on / off.
prototype LocationFinderToggle();

// Create the list of locations for a particular system
prototype list create_location_list( string system );

// Create the list box of solar system selection buttons
prototype list create_system_buttons( hwindow list_box );

// Create the window that contains the location list
prototype hwindow create_location_list_window();

// Monitor the location list for the currently focused location.
prototype task list_box_monitor( hwindow system_list_box );

// Create the location info box.
prototype create_text_box( hwindow shady_bar );

// Update the location info text box
prototype update_text_box_info( string location, string system, string faction, bool selected );

// Clear the info in the location text box.
prototype clear_text_box_info();

// Clear the right hand shady bar if the PDA screen is accessed
prototype OnPDA();

// Clear the screens if the quit button is pressed, or the screen is toggled.
prototype OnQuit();

// Target the location finder waypoint
prototype task set_hud_target( hisim waypoint );

// Sets a waypoint to the current selected location
prototype OnSetWaypoint();

// Clears the current waypoint
prototype OnClearWaypoint();

// Puts the selected location into a global handle.
prototype set_selected_location( hwindow window );

// Change the location list when a system button is pressed
prototype OnSelectSystem();

// Create a list box window for the system buttons
prototype hwindow create_combo_window( hwindow window, string title, int y, int height, bool scrollbar );

// A small task that quits the location finder screen.
prototype task quit_task();


// *********************************************
// CODE BEGINS HERE
// *********************************************



// *********************************************
// * OnPDA()
// *
// * Clear the right hand shady bar if the PDA 
// * screen is accessed
// *********************************************

OnPDA()
{
	// Set right hand shady bar width to zero.
	// We have to do this, because if the PDA screen is accessed, the right hand bar is still there.
	// So this function is bound to the SpaceFlightPDA key ( normally Esc ) and gets rid of the
	// right and shady bar.
	// For some reason if you quit the PDA screen and go back into the game the shady bar
	// re-appears (which is what we want). If it works, don't knock it. Go figure.

	GUI.SetRHSShadyBarWidth( 0 );

} // OnPDA



// *********************************************
// * OnQuit()
// *
// * Removes the screens and tidies up when the 
// * Screen is exited.
// *********************************************

OnQuit()
{
	// Halt the monitor task.
	Task.Halt( Task.Cast( Global.Handle( "g_lf_text_box_monitor_task" ) ) );

	// Set the Right Hand Shady Bar width to zero.
	GUI.SetRHSShadyBarWidth( 0 );
	
	// Get rid of the screens.
	GUI.RemoveOverlaysAfter("icSpaceFlightScreenOverlay");

	// Set the global to say the screen is no longer active.
	Global.SetBool( "g_lf_screen_active", false );

} // OnQuit



// *********************************************
// * task set_hud_target( hisim waypoint )
// *
// * Sets the HUD target to the location finder
// * waypoint.
// *********************************************

task set_hud_target( hisim waypoint )
{
	// We need this task as we have to wait for a short time before setting
	// the HUD target, otherwise it doesn't register.

	Task.Sleep( Task.Current(), 0.1 );
	iHUD.SetTarget( waypoint );

} // set_hud_target



// *********************************************
// * OnSetWayoint()
// *
// * Creates and sets the current waypoint 
// *********************************************

OnSetWaypoint()
{
	
	hisim location = iSim.Cast( Global.Handle( "g_lf_location_handle" ) );				// Get the waypoint
	hisim waypoint = iSim.Cast( Global.Handle( "g_lf_location_waypoint"	) );			// Get the current location
	hwindow text_box = GUI.Cast( Global.Handle( "g_lf_location_text_box_handle" ) );	// Get the text box handle.
	string location_name = Object.StringProperty( location, "name" );					// Location name
	string waypoint_name;																// Name for the waypoint.
	float avoidance_radius;																// Avoidance Radius

	// First destroy the old waypoint.
	Sim.Destroy( waypoint );															

	// Work out the waypoint name - we set a prefix to make the waypoint name unique. 
	// The + sign allows multiple name keys to be used in one string.
	waypoint_name = String.Join( "lf_prefix+", Object.StringProperty( location, "name" ) );

	// Create the waypoint
	waypoint = iSim.Cast( Sim.Create( "ini:/sims/nav/waypoint", waypoint_name ) );

	// Add the localised location name as a property.
	Object.AddStringProperty( waypoint, "location_name", location_name );
	
	// Place the waypoint at a safe distance from the location.
	avoidance_radius = iAI.AvoidanceRadius( location, iShip.FindPlayerShip() ) + 1km;
	Sim.PlaceRelativeTo( waypoint, location, 0, avoidance_radius, 0 );
	
	// Make it visible to sensors and on the starmap. Make it critical for good measure.
	iSim.SetSensorVisibility( waypoint, true );

	// Set the handle and system name.
	Global.SetHandle( "g_lf_location_waypoint", waypoint );
	Global.SetString( "g_lf_waypoint_system", Global.String( "g_lf_selected_system" ) );

	// Update the text box info.
	update_text_box_info( Text.Field( location_name, FT_Text ),
						  Global.String( "g_lf_selected_system" ),
						  iFaction.Name( iSim.Faction( location ) ), true );

	// We need to do this, as we need to wait a short while before setting the target
	// Otherwise it doesn't register.
	Task.Detach( start set_hud_target(  waypoint ) );

} // OnSetWaypoint



// *********************************************
// * OnClearWayoint()
// *
// * Clears the current waypoint 
// *********************************************

OnClearWaypoint()
{

	// Get the waypoint from the global.
	hsim waypoint = Sim.Cast( Global.Handle( "g_lf_location_waypoint" ) );			
	
	// Destroy it
	Sim.Destroy( waypoint );								

	// Clear the text box
	clear_text_box_info();
	
	// Set the waypoint global to a null handle.
	Global.SetHandle( "g_lf_location_waypoint", none );

} // OnClearWaypoint



// ************************************************
// * set_selected_location( hwindow window )
// *
// * Get the handle from the location from the window
// * property, and put it into a global.
// ************************************************

set_selected_location( hwindow window )
{
	
	// Get the location handle.
	hsim location = Sim.Cast( Object.HandleProperty( window, "location_handle" ) );
	
	// Set the location handle global.
	Global.SetHandle( "g_lf_location_handle", location);

	debug Debug.PrintString( "LocationFinder: Location selected = " );
	debug Debug.PrintString( Text.Field( Object.StringProperty( location, "name" ), FT_Text ) );
	debug Debug.PrintString( "\n" );

} // set_selected_location



// ************************************************
// * OnSelectLocation()
// *
// * When a location list entry is clicked on, get
// * the window ID, then set the location selected.
// ************************************************

OnSelectLocation()
{
	// Get the window
	hwindow selected_location =   GUI.FocusedWindow();
	
	// Set the locatio selected.
	set_selected_location( selected_location );	

} // OnSelectedLocation



// ************************************************
// * OnSelectSystem()
// *
// * When a system list entry is clicked on, get
// * change the current system, and update the
// * location list.
// ************************************************

OnSelectSystem()
{

	// Get the currently focused window - it must be the correct system button.
	hwindow selected_system =   GUI.FocusedWindow();
	
	// Create the list of locations for the system using the map property on the button.
	list location_list = create_location_list( Object.StringProperty( selected_system, "system_map" ) );

	// Update the location list global so the location box monitor can find it.
	Global.SetList( "g_lf_location_list", location_list );
	
	// Set the selected system global so other routines can use it.
	Global.SetString( "g_lf_selected_system", Object.StringProperty( selected_system, "system_name" ) );
	
	// Destroy the old location list window.
	GUI.DeleteWindow( GUI.Cast( Global.Handle( "g_lf_location_window" ) ) );
	
	// Create a new location list window.
	create_location_list_window();

} // OnSelectSystem



// ************************************************
// * list create_location_list( string system )
// * 
// * When a system list entry is clicked on, get
// * change the current system, and update the
// * location list.
// ************************************************

list create_location_list( string system )
{

	// Get the set of habitats 
	set habitats = iHabitat.FilterOrbiting( 
							iMapEntity.SystemHabitatsInSystem( system ) );

	// Get the set of L-Points
	set lpoints = iMapEntity.SystemLagrangePointsInSystem( system );
	set locations;

	hmapentity current_location; // Current location being indexed.
	
	hwindow current_window;		 // Current window being created. 
	
	list location_list;			 // List of locations

	string location_name;		 // The name of the location.

	// Join the habitat and lpoint sets together.
	Set.Union( locations, habitats );
	Set.Union( locations, lpoints );
	
	debug
	{
		Debug.PrintString( "LocationFinder: System = ");
		Debug.PrintString( system );
		Debug.PrintString( " Habitats found = " );
		Debug.PrintInt( Set.ItemCount( habitats ) );
		Debug.PrintString( ", L-Points found = " );
		Debug.PrintInt( Set.ItemCount( lpoints ) );
		Debug.PrintString( ", Total = " );
		Debug.PrintInt( Set.ItemCount( locations ) );
		Debug.PrintString( "\n" );
	}

	// Filter the set of locations, removing any hidden or non-mapped
	// locations. Also builds a set of windows for use in the selection box.

	debug Debug.PrintString( "LocationFinder.create_location_list: Filtering locations and building buttons\n" );

	do
	{
		// Get the location
		current_location = iMapEntity.Cast( Set.FirstElement( locations ) );
		
		// Remove it from the set
		Set.Remove( locations, current_location );

		
		// Ensure that it's map visible
		if ( ! iMapEntity.IsVisibleOnMap( current_location ) )
		{
			debug atomic
			{
				Debug.PrintString( "LocationFinder: Filtering non-map visible location - " );
				Debug.PrintString( Object.StringProperty( current_location, "name" ) );
				Debug.PrintString( "\n" );
			}
		
		} 
	
		// Check it's not hidden.
		else if ( iMapEntity.IsHidden( current_location ) )
		{				
				debug atomic
				{
					Debug.PrintString( "LocationFinder: Filtering hidden location - " );
					Debug.PrintString( Object.StringProperty( current_location, "name" ) );
					Debug.PrintString( "\n" );
				}
			
		}
		else
		{
			// Create a parentless window for the selection box.
			location_name = Text.Field( Object.StringProperty( current_location, "name" ), FT_Text );

			// Add the current location's name and handle to the window, so we can use it later.
			Object.AddStringProperty( current_location, "location_name", location_name  );
			
			// Add the location to the location list.
			List.AddTail( location_list, current_location );
			
			atomic
			{
				debug
				{
					Debug.PrintString( "LocationFinder: Adding Valid Location - " );
					Debug.PrintString( Object.StringProperty( current_location, "name" ) );
					Debug.PrintString( "\n" );
				}	
			}

		}
	}
	while( ! Set.IsEmpty( locations ) );

	debug Debug.PrintString( "LocationFinder.create_location_list: Finished building buttons.\n" );

	// Return a sorted list of locations.
	return List.SortByStringProperty( location_list, "location_name" );

} // create_location_list


// ************************************************
// * list create_system_buttons( hwindow list_box )
// * 
// * Create the solar system selection button list.
// ************************************************

list create_system_buttons( hwindow list_box )
{
	// A list of windows - the splitter and the buttons within it.
	list buttons;

	// The position of the splitter window
	int splitter_left;
	int splitter_top;

	hwindow button;		// The current button being processed
	
	// System info
	string system_name;		
	string system_map;

	// Number of entries in the inifile, and buttons to create.
	int name_entries;
	int map_entries;
	int entries;
	int count;

	// Button dimensions
	int button_height = Global.Int( "GUI_inversebutton_height" );
	int list_box_gap = 3;
	int button_width = Global.Int( "GUI_inversebutton_width" );

	// Open the cluster.ini to get the system info.
	hinifile cluster_ini = INIFile.Create( "ini:/geog/clusters" );

	// First find out how many systems we have. 

	// Note that we are using a modified clusters.ini file which contains the name keys of the various systems
	// in addition to the map urls.

	entries = iUtilities.FindNumberOfINIEntries(  cluster_ini,  "badlands", "system" );

	// Create and initialise the inverse buttons and add them to a list for a 
	// standard layout function and control focus ordering. 

	for ( count = 0 ; count < entries ; ++count )
	{
		// Get the system name.
		system_name = INIFile.NumberedString( cluster_ini,
													  "badlands",
													  "name",
													   count,
													   "Name Error!" );

		// Get the system map URL. Note that if there is no entry, the default hoffers_wake map is used.
		system_map = INIFile.NumberedString( cluster_ini, "badlands",
													  "system",
													   count,
													   "map:/geog/badlands/hoffers_wake" );

		debug atomic
		{
			Debug.PrintString( "LocationFinder: Creating button for system - " );
			Debug.PrintString( Text.Field( system_name, FT_Text ) );
			Debug.PrintString( "\n" );
		}	
		

		// Create a special parentless rectangular inverse button
		button = iGUI.CreateAndInitialiseRectangularInverseRadioButton( 
			none,
			0,
			0,
			button_width,
			Text.Field( system_name, FT_Text),
			false );
		
		iGUI.MakeRectangularInverseButtonIconic( button );

		// Add the system name and url to the button so we can retrieve it later.
		Object.AddStringProperty( button, "system_name", Text.Field( system_name, FT_Text ) );
		Object.AddStringProperty( button, "system_map", system_map );

		// Set the override, so that the button activates the system selection routine when
		// a mouse is clicked on it.
		
		// Note that we have to use the GUI override function to find out
		// what button is pressed, as the GUI.ListBoxSelectedIndex command
		// doesn't seem to work!

		GUI.SetInputOverrideFunctions( 
			button,
			"", 
			"",
			"", 
			"", 
			"", 
			"",
			"LocationFinder.OnSelectSystem",
			"",
			"" );

		// Add the button to the list.
		List.AddTail( buttons, button );


	} // End for

	// Close the inifile.  
	INIFile.Destroy( cluster_ini );

	// Sort the buttons by name
	buttons = List.SortByStringProperty( buttons, "system_name" );

	// Add the sorted buttons into the list box.
	for ( count = 0 ; count < List.ItemCount( buttons ) ; ++count )
	{
		// Add the button to the list box
		GUI.AddListBoxEntry( list_box, GUI.Cast( List.GetNth( buttons, count ) ) );
	}

	// Return the button list
	return buttons;

} // create_system_buttons



// ************************************************
// * hwindow create_combo_window( hwindow window,
// *						      string title,
// *							  int y,
// * 							  int height,
// *							  bool scrollbar )
// * 
// * Create the solar system selection box.
// ************************************************

hwindow create_combo_window( hwindow window, string title, int y, int height, bool scrollbar )
{

	hwindow pane;				// One of the splitter windows.
	hwindow title_window;		// The title window of the splitter

	hsim current_location;		// The current location being processed.

	// Set the title font
	string title_font = Global.String( "GUI_subtitle_font" );

	// Set the box button size and gaps.	
	int button_height = Global.Int( "GUI_inversebutton_height" );
	int list_box_gap = 3;
	int button_width = Global.Int( "GUI_inversebutton_width" );

	int i; // Counter

	// Get the width of a scrollbar
	int scrollbar_width = Global.Int( "GUI_scrollbar_width" );

	// Window handles for the various parts of the list box.
	hwindow list_box;
	hwindow button;
	hwindow splitter;

	list buttons;			// List of buttons
	list location_list;		// List of locations
	
	// Splitter dimension parameters.
	int x;
	int width;
	int splitter_y_bottom_offset = 120;
	int splitter_alignment_offset = 4;
	int split = ( 2 * Global.Int( "GUI_fancyborder_width" ) ) + 13;
	int element_gap = 10;

	
	// Work out x and y positions of the splitter
	x = Global.Int( "GUI_alignment_offset" ) + splitter_alignment_offset;
		
	// Work out the width and height of the splitter
	width = Global.Int( "GUI_shader_width" ) + splitter_alignment_offset - ( x * 2 );
	
	// If the height is -1 we assume the height is the full height of the window.
	if ( height == -1 )
	{
		// Height has to allow for the text window at the bottom.
		height = ( GUI.WindowCanvasHeight( window ) - ( y + splitter_y_bottom_offset ) );
	}
	
	// Create the splitter window that contains the list box.
	splitter = GUI.CreateSplitterWindow( 
		x, y,
		width, height, 
		window, 
		split,
		false );

	// Create a title window in the top pane of the splitter window

	// Get the top pane
	pane = GUI.SplitterWindowTopWindow( splitter );
	
	// Put a static window in the pane with the title in
	title_window = iGUI.CreateAndInitialiseStaticWindow( 
		0, 
		0,
		GUI.WindowCanvasWidth( pane ), 
		GUI.WindowCanvasHeight( pane ),
		pane,
		title_font,
		Text.Field( title, FT_Text ) );

	// Set the text formatting
	GUI.SetWindowTextFormatting( title_window, false, 9 );

	// Get the bottom pane
	pane = GUI.SplitterWindowBottomWindow( splitter );

	// Check if we need a scollbar
	if ( scrollbar )
	{	
		// We will have a smaller button width as we will always have a scrollbar.
		button_width -= ( scrollbar_width + 4);
	}

	// Create the list box
	list_box = GUI.CreateListBox( 
		0, 0,
		button_width,
		GUI.WindowCanvasHeight( pane ),
		pane,
		true,
		false );

	// Add the list box to the interactive window element list
	List.AddHead( location_list, list_box );

	// Add the scrollbar if required
	if ( scrollbar )
	{
		GUI.CreateVerticalScrollbar( 
			GUI.WindowCanvasWidth( pane ) - scrollbar_width, 
			0,
			scrollbar_width, 
			GUI.WindowCanvasHeight( pane ),
			pane,
			list_box,
			Global.Float( "GUI_scrollbar_buttonratio" ),
			"" );
	}

	// Return the list box
	return list_box;

} // reate_combo_window



// ******************************************
// * clear_text_box_info( hwindow text_box )
// *
// * Displays default text box info.
// ******************************************
clear_text_box_info()
{
	// Get handle for upper text box.
	hwindow text_box_upper = GUI.Cast( Global.Handle( "g_lf_location_text_box_upper_handle" ) );

	// Get handle for lower text box
	hwindow text_box_lower = GUI.Cast( Global.Handle( "g_lf_location_text_box_lower_handle" ) );

	string text; // String for html
	
	// Build the html
	text = Text.Field( "lf_no_waypoint_set", FT_Text );
	text = String.Join( "<HTML><BODY>", text);
	text = String.Join( text, "</HTML></BODY>" );
	
	// Set the text box strings.
	GUI.SetTextWindowString( text_box_upper, text );
	GUI.SetTextWindowString( text_box_lower, "" );

} // clear_text_box_info



// *********************************************
// * hwindow create_location_list_window()
// *
// * Creates the window that holds the location
// * list box.
// *********************************************
hwindow create_location_list_window()
{

	// Window handles
	hwindow pane;
	hwindow title_window;
	hwindow shady_bar = GUI.Cast( Global.Handle( "g_lf_shady_bar" ) );
	hwindow list_box;
	hwindow splitter;

	// Title font
	string title_font = Global.String( "GUI_subtitle_font" );

	// Button parameters.
	int button_height = Global.Int( "GUI_inversebutton_height" );
	int list_box_gap = 3;
	
	int i; // Counter

	
	list location_list; // List of locations.

	// Splitter dimension parameters.
	int x;
	int y;
	int width;
	int height;
	int splitter_y_bottom_offset = 120;
	int splitter_alignment_offset = 4;
	int split = ( 2 * Global.Int( "GUI_fancyborder_width" ) ) + 13;
	int element_gap = 10;

	hmapentity current_location;								// Current location being processed
	string location_name;										// Current location name
	int max_title_length = 19;									// Title length parameter
	hwindow button;												// Current button being processed
	int button_count;											// Count of buttons
	int button_width = Global.Int( "GUI_inversebutton_width" ); // Width of the buttons.
	list buttons;												// List of buttons.
	int scrollbar_width = Global.Int( "GUI_scrollbar_width" );	// Scrollbar width
	string title;												// Title
	hwindow scroll_bar;											// Scrollbar handle

	
	// Work out x and y positions of the splitter
	x = Global.Int( "GUI_alignment_offset" ) + splitter_alignment_offset;
	y = 0;
	
	// Work out the width and height of the splitter
	width = Global.Int( "GUI_shader_width" ) + splitter_alignment_offset - ( x * 2 );
	// height = ( y - (games_splitter_y_offset + element_gap ));
	
	// Height has to allow for the text window at the bottom.
	height = ( GUI.WindowCanvasHeight( shady_bar ) - ( y + splitter_y_bottom_offset ) );
	
	// Create the splitter window that contains the list box.
	splitter = GUI.CreateSplitterWindow( 
		x, y,
		width, height, 
		shady_bar, 
		split,
		false );

	// Set a global for the window so we can delete it when we re-create this screen.
	// Note: Originally I was simply going to remove all the buttons from the list
	//       box and create a new list of buttons when changing system.
	//       Unfortunately, the scrollbar wouldn't reset and the list box wouldn't
	//       scroll properly. I then tried to delete the list box and re-create it.
	//       Unfortunately that crashed the game, so in the end whenever the system
	//       is changed the entire location window, along with its child windows are
	//       is deleted and re-created.

	Global.SetHandle( "g_lf_location_window", splitter );

	// Get the top pane of the splitter, for the title.
	pane = GUI.SplitterWindowTopWindow( splitter );
	
	// Put a static window in the pane with the title in
	title_window = iGUI.CreateAndInitialiseStaticWindow( 
		0, 
		0,
		GUI.WindowCanvasWidth( pane ), 
		GUI.WindowCanvasHeight( pane ),
		pane,
		title_font,
		title );

	// Create a global for the title window so we can change the title if necessary.
	Global.SetHandle( "g_lf_location_title_window", title_window );

	// Set the text formatting
	GUI.SetWindowTextFormatting( title_window, false, 9 );

	// Get the bottom pane
	pane = GUI.SplitterWindowBottomWindow( splitter );
	
	// We will have a smaller button width as we will always have a scrollbar.
	button_width -= ( scrollbar_width + 4);
	
	// Create the list box 

	list_box = GUI.CreateListBox( 
		0, 0,
		button_width,
		GUI.WindowCanvasHeight( pane ),
		pane,
		true,
		false );

	// Set the global for the list box.
	Global.SetHandle( "g_lf_location_list_box_handle", list_box );
	
	// Attach a scrollbar to the list box.
	GUI.CreateVerticalScrollbar( 
		GUI.WindowCanvasWidth( pane ) - scrollbar_width, 
		0,
		scrollbar_width, 
		GUI.WindowCanvasHeight( pane ),
		pane,
		list_box,
		Global.Float( "GUI_scrollbar_buttonratio" ),
		"" );


	// Get the location list from the global
	location_list = Global.List( "g_lf_location_list" );

	// Count the buttons
	button_count = List.ItemCount( location_list );

	// Create the title for the window. It's the system name plus number of locations.
	title = String.Join( title, String.FromInt( List.ItemCount( location_list ) ) );
	title = String.Join( title, " " );

	// Use a non-plural if the number of locations is 1.
	if ( button_count == 1 )
	{
		title = String.Join( title, Text.Field( "lf_viewing_location", FT_Text ) );
	}
	else
	{
		// Otherwise use the plural
		title = String.Join( title, Text.Field( "lf_locations", FT_Text ) );
	}


	// Set the title and title window text formatting
	GUI.SetWindowTitle( GUI.Cast( Global.Handle( "g_lf_location_title_window" ) ),  title  );
	GUI.SetWindowTextFormatting( GUI.Cast( Global.Handle( "g_lf_location_title_window" ) ), false, 0 );
	
	// Create all the buttons for the set of locations
	atomic
	{
		// For each of the locations
		for ( i = 0; i < button_count; ++i )
		{
			
			// Get the location and its name
			current_location = iMapEntity.Cast( List.GetNth( location_list, i ) );
			location_name = Object.StringProperty( current_location, "location_name" );

			debug
			{
				Debug.PrintString( "LocationFinder: Creating button for location - " );
				Debug.PrintString( location_name );
				Debug.PrintString( "\n" );
			}	

			// Clip the title if it's longer than the max_title_length.
			if ( String.Length( location_name ) >= max_title_length )
			{
				location_name = String.Left( location_name, max_title_length );
				location_name = String.Join( location_name, "..." );
			}

			// Create a special parentless rectangular inverse button
			button = iGUI.CreateAndInitialiseRectangularInverseRadioButton( 
				none,
				0,
				0,
				button_width,
				location_name,
				false );
			iGUI.MakeRectangularInverseButtonIconic( button );
			List.AddTail( buttons, button );

			// Note that we have to use the GUI override function to find out
			// what button is pressed, as the GUI.ListBoxSelectedIndex command
			// doesn't seem to work!

			GUI.SetInputOverrideFunctions( button,
											"", 
											"",
											"", 
											"", 
											"", 
											"",
											"LocationFinder.OnSelectLocation",
											"",
											"" );

			// Add the package & map name as a property to the button
			Object.AddHandleProperty( button, "location_handle", List.GetNth( location_list, i ) );
			Object.AddStringProperty( button, "location_name", location_name );

			// Add the button to the list box
			GUI.AddListBoxEntry( list_box, button );
		
		}	
		
		// Make the first entry of the list box the one that's selected.
		GUI.SelectListBoxEntry( list_box, 0 );
		button = GUI.Cast( List.Head( buttons ) );
		set_selected_location( button );

	}

	// Return the window handle, in case we need it.
	return splitter;

} // create_location_list_window



// **************************************
// update_text_box_info( string location,
//						string system,
//						string faction,
//						bool selected )
//
// Update the info that appears in the
// location information text box.
// Essentially it builds html strings.
// **************************************

update_text_box_info( string location, string system, string faction, bool selected )
{
	
	// Get handle for upper text box.
	hwindow text_box_upper = GUI.Cast( Global.Handle( "g_lf_location_text_box_upper_handle" ) );

	// Get handle for lower text box
	hwindow text_box_lower = GUI.Cast( Global.Handle( "g_lf_location_text_box_lower_handle" ) );
	
	string html;																		// The html string.
	string header = "<HTML><BODY>";														// The first bit of html
	string footer = "</BODY></HTML>";													// The last bit of html.
	string viewing_location_heading = Text.Field( "lf_viewing_location", FT_Text );		// The 'VIEWING LOCATION' header
	string selected_location_heading = Text.Field( "lf_selected_location", FT_Text );	// The 'SELECTED LOCATION' header
	string system_heading = Text.Field( "lf_system", FT_Text );							// The 'SYSTEM' heading
	string faction_heading = Text.Field( "trading_faction", FT_Text );					// The 'FACTION' heading

	
	// Set the html for the upper window
	// If the location is selected it displays 'SELECTED LOCATION, 
	
	if ( selected )
	{
		html = String.Join( header, selected_location_heading );
		
	}
	else
	{
		// Otherwise it displays 'LOCATION'
		html = String.Join( header, viewing_location_heading );
	}
	
	// Build the rest of the html.
	html = String.Join( html, ":<BR>" );
	html = String.Join( html, location );
	html = String.Join( html, footer );

	// Update the upper window text.
	GUI.SetTextWindowString( text_box_upper, html );

	// HTML for the system name section
	html = String.Join( header, "<BR>" );
	html = String.Join( html, system_heading );
	html = String.Join( html, ": " );
	html = String.Join( html, system );


	// HTML for the faction name section.
	html = String.Join( html, "<BR>" );
	html = String.Join( html, faction_heading );
	html = String.Join( html, ": " );
	html = String.Join( html, Text.Field( faction, FT_Text ) );
	html = String.Join( html, footer );

	// Update the lower window text
	GUI.SetTextWindowString( text_box_lower, html );

} // update_text_box_info



// *********************************************
// * create_text_box( hwindow shady_bar )
// *
// * Create the text box that displays the
// * location info.
// *********************************************

create_text_box( hwindow shady_bar )
{
	hwindow border_box;			// Handle for the border window
	hwindow text_box_upper;		// Handle for upper text box.
	hwindow text_box_lower;		// Handle for lower text box.
	
	int bottom_border = 24;														// How far off the bottom to put the windows.
	int splitter_alignment_offset = 4;											// How far across to put the box
	int height = 80;															// The height of the box
	int x = Global.Int( "GUI_alignment_offset" ) + splitter_alignment_offset;	// Work out the x coordinate of the box
	int y = GUI.WindowCanvasHeight( shady_bar ) - ( height + bottom_border );   // Work out the y coordinate of the box
	int width = Global.Int( "GUI_shader_width" ) - ( x * 2 );					// Work out the width of the box.

	// Create the border box.
	border_box = GUI.CreateStaticWindow( x, y, width, height, shady_bar );		
	GUI.CreateBorder( border_box );

	// Create the upper and lower text boxes.
	text_box_upper = GUI.CreateTextWindow( x, y, width, height / 2, shady_bar );
	text_box_lower = GUI.CreateTextWindow( x, y + ( height / 2 ), width, height / 2, shady_bar );

	// 	Set their fonts.
	GUI.SetWindowFont( text_box_upper, Global.String( "GUI_detail_font" ) );
	GUI.SetWindowFont( text_box_lower, Global.String( "GUI_detail_font" ) );

	// Set Global handle for the location upper text box.
	Global.SetHandle( "g_lf_location_text_box_upper_handle", text_box_upper );

	// Global handle for the location lower ltext box.
	Global.SetHandle( "g_lf_location_text_box_lower_handle", text_box_lower );

} // create_text_box


// *********************************************
// * LocationFinderScreen()
// *
// * Creates and displays the actual location
// * finder GUI screen,
// *********************************************

LocationFinderScreen()
{
	// Windows
	hwindow shady_bar;				// Left hand side shady bar
	hwindow shady_bar_r;			// Right hand side shady bar
	hwindow location_list_box;		// The location list box
	hwindow system_list_box;		// The system list box
	hwindow text_box;				// Text box containing the locaton info.
	hwindow current_button;			// The current button being processed.
	
	int count;						// A counter
	int waypoint_border_left;		// Left coordinate for the wayoint button border.
	int waypoint_border_top;		// Top coordinate for the waypoint button border.

	list location_list;				// List of sims in the location list
	list system_button_list;		// List of buttons in the system button list
	list location_button_list;		// List of buttons in the location button list
	list waypoint_button_list;		// List of buttons for waypoint button list;
	list temp_list;					// Temporary list.

	htask location_text_box_monitor; // Handle for the text box monitor task.
	
	// Get the current map.
	string active_world = iSim.ActiveWorld();
	string title;

	// We don't want any movies.
	GUI.StopAllMovies();

	// Set the default font.
	GUI.SetDefaultFont( Global.String( "GUI_title_font" ) );

	// Create both right and left shady bars.
	shady_bar = iGUI.CreateShadyBar();
	shady_bar_r = iGUI.CreateShadyBarRight();

	// Set a global for the right hand shady bar, so other LocationFinder functions can use it.
	Global.SetHandle( "g_lf_shady_bar", shady_bar_r );

	// Set the title
	iGUI.AddTitle( shady_bar, Text.Field( "lf_location_finder", FT_Text ) );

	// Create the windows for the left hand side shady bar.
	// ****************************************************
	
	// First of all create the system list box.
	system_list_box = create_combo_window( shady_bar,
										Text.Field( "lf_system", FT_Text ),
										Global.Int( "GUI_title_yoffset" ) + 23,
										335, false );

	// Create a global handle for this list box, so the gui functions can access it.
	Global.SetHandle( "g_lf_system_listbox_handle", system_list_box );

	// The list box itself may get the focus, instead of the buttons, so we'll deal with that separately.
	GUI.SetListBoxSelectFunction( system_list_box, "LocationFinder.OnSystemSelect" );

	// Fill the system list with buttons.
	system_button_list = create_system_buttons( system_list_box );
	
	// Create a global handle for the system button list so the gui functions can access it.
	Global.SetList( "g_lf_system_button_list", system_button_list );

	// By default location finder always defaults to the current system, so 
	// find  the list box entry for the current system, and set it selected

	for ( count = 0 ; count < List.ItemCount( system_button_list ) ; ++count )
	{
		// Get the button
		current_button = GUI.Cast( List.GetNth( system_button_list, count ) );
		
		// If the active world matches the map property on the button...
		if ( Object.StringProperty( current_button, "system_map" ) == active_world )
		{
			// Set the global for the current system name.
			Global.SetString( "g_lf_selected_system", Object.StringProperty( current_button, "system_name" ) );
		
			GUI.SelectListBoxEntry( system_list_box, count );
			break;
		}

	}


	// Create the set and clear waypoint buttons 
	// *****************************************
	
	// Create the set waypoint button
	current_button = iGUI.CreateAndInitialiseParentlessInverseButton( 
			"LocationFinder.OnSetWaypoint",
			Text.Field( "lf_set_waypoint", FT_Text ),
			waypoint_button_list );

		// Override the functions
		GUI.SetInputOverrideFunctions( 
			current_button,
			"", "", "", "", "", 
			"LocationFinder.OnQuit",
			"", "", "" );


	// Create the clear waypoint button
	current_button = iGUI.CreateAndInitialiseParentlessInverseButton( 
			"LocationFinder.OnClearWaypoint",
			Text.Field( "lf_clear_waypoint", FT_Text ),
			waypoint_button_list );

		// Override the functions
		GUI.SetInputOverrideFunctions( 
			current_button,
			"", "", "", "", "", 
			"LocationFinder.OnQuit",
			"", "", "" );	
	
	// Work out the splitter window left and top
	waypoint_border_left = Global.Int( "GUI_alignment_offset" ) + Global.Int( "GUI_fancyborder_alignmentoffset" );
	waypoint_border_top = GUI.WindowCanvasHeight( shady_bar ) - 90;
		
	// Create the splitter using a layout helper
	iGUI.CreateWindowListInFancyBorder( 
		shady_bar,
		waypoint_button_list, 
		waypoint_border_left, 
		waypoint_border_top );

			
	// Create the exit button
	current_button = iGUI.CreateAndInitialiseFancyButton( 
		shady_bar,
		GUI.WindowCanvasHeight( shady_bar ) - ( Global.Int( "GUI_fancybutton_height" ) + 8 ),
		Text.Field( "lf_exit", FT_Text ),
		"LocationFinder.OnQuit" );

	

	// Create the windows for the right hand side shady bar.
	// *****************************************************

	//Create a sorted location list for the current world. This is the default when first running the screen.
	location_list = create_location_list( active_world );

	// Create a global handle for the location list so the gui functions can access it.
	Global.SetList( "g_lf_location_list", location_list );

	// Splitter window and list box. Returns the list_box handle, as this is what's used for the location buttons.
	location_list_box = create_location_list_window();
	Global.SetHandle( "g_lf_location_window", location_list_box );

	// Text box for location info.
	create_text_box( shady_bar_r );

	// Start the location box monitor ( displays the text in the info box. )
	// We put this into a handle for when the screen is quit.
	
	location_text_box_monitor = start list_box_monitor( system_list_box );
	Global.SetHandle( "g_lf_text_box_monitor_task", location_text_box_monitor );
	Task.Detach( location_text_box_monitor );

} // LocationFinderScreen



// *********************************************
// * quit_task()
// *
// * Starts the window quit function.
// * Doing it this way stops the game from
// * crashing if the text box monitor task
// * needs to remove the location finder screen.
// *********************************************

task quit_task()
{
	OnQuit();
}



// ***************************************************
// * task list_box_monitor( hwindow system_list_box )
// *
// * Monitors the location list box to update the 
// * location text box.
// * Also removes the location finder screen if the
// * game goes into an external camera or director
// * mode.
// ****************************************************

task list_box_monitor( hwindow system_list_box )
{
	// Track the currently selected list box entry
	hwindow currently_selected = none;
	hwindow selected;
	
	hwindow location_list_box;	// List box for the locations

	// Track the currently focused list box entry

	int focused_index;													// Location window focused index
	int	previous_focus = -1;											// Previous location window focused
	int selected_index = GUI.ListBoxSelectedIndex( system_list_box );	// Currently selected location list box index
	int previous_selected = selected_index;								// Previous location list box selected index

	hwindow selected_window = GUI.ListBoxValue( system_list_box );		// Currently selected system window.
	hwindow previous_window = selected_window;							// Previously selected window

	hisim location_handle;												// Handle for the currently selected location.


	// The text to set in the text box
	string location_text = "None";
	string system_text = "None";
	string faction_text = "None";

	string current_screen;					// Current screen name being used.

	bool update_waypoint_location = true;	// Boolean governing if the location waypoint info needs updating.


	// Forever...
	while( 1 )
	{
		// Quit the screen if the director mode comes on.
		// This is to prevent the screen overlaying a cut-scene, and causing problems.
		if ( iDirector.IsBusy() )
		{
			// Use the quit_task as the game crashes if you use OnQuit() directly here.
			Task.Detach( start quit_task() );
			return;
		}

		// Quit the screen if the player ship capsule jumps.
		// This is to prevent the screen overlaying the capsule jump sequence, and causing problems.
		if ( iSim.IsCapsuleJumping( iShip.FindPlayerShip() ) )
		{
			// Use the quit_task as the game crashes if you use OnQuit() directly here.
			Task.Detach( start quit_task() );
			return;
		}

		// Quit the screen if the player ship capsule jumps.
		// This is to prevent the screen overlaying the external cameras, and causing problems.
		if ( ( iDirector.Camera() != CAM_Internal ) && ( iDirector.Camera() != CAM_InternalNoCockpit ) )
		{
			// Use the quit_task as the game crashes if you use OnQuit() directly here.
			Task.Detach( start quit_task() );
			return;
		}
		
		// Get the location list box handle.
		location_list_box = GUI.Cast( Global.Handle( "g_lf_location_list_box_handle" ) );
		
		// Continually check the list boxes for selections.
		focused_index = GUI.ListBoxFocusedEntry( location_list_box );
		
		// If a window in the location list box is being focused... ( -1 is no focus )
		if ( focused_index != -1 )
		{
			
			// ... and it has changed from the previous focus can display the info for the
			//     currently focused location.

			if ( focused_index != previous_focus )
			{
				
				// Get the handle of the location, from the location list so we can find a few things about it.
				location_handle = iMapEntity.Cast( List.GetNth( Global.List( "g_lf_location_list" ), focused_index ) );

				// Find the name of the location.
				location_text = Text.Field( Object.StringProperty( location_handle, "name" ), FT_Text );

				// Find the system of the location
				system_text = Global.String( "g_lf_selected_system" );

				// Find the faction name of the location
				faction_text = iFaction.Name( iSim.Faction( location_handle ) );
			
				// Update the text box, saying this is the viewing location.
				update_text_box_info( location_text, system_text, faction_text, false );
				
				// Set the previous focus so we can check if we need to update the box next time.
				previous_focus = focused_index;
			
			} // End if focused = previous
		
			// Reset the need to update the location waypoint, as the info for the 
			// waypoint will have been overwritten by the focused location.
			update_waypoint_location = true;
		
		}
		else
		{
			// If there's nothing focused, we check if there's a location waypoint set, and display
			// that instead.

			// Reset the previous focus.
			previous_focus = -1;

			// Only do this if we need to update the waypoint location in the text box.
			if ( update_waypoint_location )
			{
				
				// Check the handle, as we'll print different info depending on the
				// handle status.
				location_handle = iSim.Cast( Global.Handle( "g_lf_location_waypoint" ) );

				// Find the name of the location.
				location_text = Text.Field( Object.StringProperty( location_handle, "location_name" ), FT_Text );

				// Find the system of the location
				system_text = Global.String( "g_lf_waypoint_system" );

				// Find the faction name of the location
				faction_text = iFaction.Name( iSim.Faction( location_handle ) );

				// If the location handle is null, that means no location waypoint is set.
				if ( location_handle == none )
				{
					clear_text_box_info();
				}
				else
				{
					// Update the text box, saying this is the set location.
					update_text_box_info( location_text, system_text, faction_text, true );
				}

				// Set the previous handle so we can check if we need to update the box next time.
				//previous_location_handle = location_handle;

				update_waypoint_location = false;
			
			} // End if update location waypoint

		} // End else focused index = -1

		// Sleep for a short time.
		Task.Sleep( Task.Current(), 0.1 );

	} // End while

} // list_box_monitor



// **********************************************
// * LocationFinderToggle()
// *
// * Toggles the location finder screen on / off
// **********************************************
LocationFinderToggle()
{
	
	// Perform some checks before running
	
	// Don't run if the game is in director mode, as it could cause nasty problems
	// and doesn't look good when it's overlaid on a director screen.

	if ( iDirector.IsBusy() )
	{
		debug Debug.PrintString( "LocationFinderToggle: Not running. Director mode active.\n");
		return;
	}


	// Don't run if the ship is capsule jumping as it could cause nasty problems
	// and doesn't look good when it's overlaid while capsule jumping.

	if ( iSim.IsCapsuleJumping( iShip.FindPlayerShip() ) )
	{
		debug Debug.PrintString( "LocationFinderToggle: Not running. Player is capsule jumping.\n");
		return;
	}

	// Don't run if the game isn't in an internal camera as it could cause nasty problems
	// and doesn't look good when it's overlaid on an external camera.

	if ( ( iDirector.Camera() != CAM_Internal ) && ( iDirector.Camera() != CAM_InternalNoCockpit ) )
	{
		debug Debug.PrintString( "LocationFinderToggle: Not running. Player is capsule jumping.\n");
		
		// Play a sound to let you know you can't start the location finder.
		iHUD.PlayAudioCue( AC_InvalidInput );
		return;
	}

	// Determine if the screen is active or not.
	if ( Global.Bool( "g_lf_screen_active" ) == false )
	{
		// Set the global so we know we're running the screen.
		Global.SetBool( "g_lf_screen_active", true );

		// Activate the screen.
		GUI.PopScreensTo("icSpaceFlightScreen");
		GUI.OverlayScreen("icPDAOverlayManager");
		iGUI.OverlayCustomScreen( "LocationFinder.LocationFinderScreen" );
	}
	else
	{
		// The screen is active, so quit the screen.
		OnQuit();
	}

} // LocationFinderToggle



// *****************************************
// * Initialise()
// *
// * Initialise the location finder resources
// *****************************************
Initialise()
{
	list empty_list; // Empty list for global initialisation
	

	// Check the game type - this mod can only run in a single player game.
	if ( iGame.GameType() != IGT_SinglePlayer )
	{
		debug Debug.PrintString( "LocationFinder.Initialise: Not Initialising. Game is not in single player mode.\n");
		return;
	}
	

	// Globals
	// ********
	
	debug Debug.PrintString( "LocationFinder.Initialise: Initialising globals and key bindings\n");

	// We need to use globals to communicate with the various functions of this
	// package because it's virtually the only way to get the various handles
	// to the various windows and other items.
	// Note these globals are configured not to save out, so they don't clutter the save game.

	// Global handle for monitor task.
	Global.CreateHandle( "g_lf_text_box_monitor_task", GA_Write | GA_NoSave, none );

	// Global handle for the location list box.
	Global.CreateHandle( "g_lf_location_list_box_handle", GA_Write | GA_NoSave, none );

	// Global handle for the location upper text box.
	Global.CreateHandle( "g_lf_location_text_box_upper_handle", GA_Write | GA_NoSave, none );

	// Global handle for the location lower ltext box.
	Global.CreateHandle( "g_lf_location_text_box_lower_handle", GA_Write | GA_NoSave, none );
	
	// Global handle for the left hand shady bar
	Global.CreateHandle( "g_lf_shady_bar", GA_Write | GA_NoSave, none );
	
	// Global handle for the solar system list box.
	Global.CreateHandle( "g_lf_system_listbox_handle", GA_Write | GA_NoSave, none );
	
	// Global handle for the location list box title window
	Global.CreateHandle( "g_lf_location_title_window", GA_Write | GA_NoSave, none );
	
	// Global handle for the location window.
	Global.CreateHandle( "g_lf_location_window", GA_Write | GA_NoSave, none );

	// Global handle for the location handle 
	Global.CreateHandle( "g_lf_location_handle", GA_Write | GA_NoSave, none );

	// Global handle for the location waypoint 
	Global.CreateHandle( "g_lf_location_waypoint", GA_Write | GA_NoSave, none );
	
	// Global list for the location list.
	Global.CreateList( "g_lf_location_list", GA_Write | GA_NoSave, empty_list );
	
	// Global list for the system button list
	Global.CreateList( "g_lf_system_button_list", GA_Write | GA_NoSave, empty_list );

	// Global string for the selected system name.
	Global.CreateString( "g_lf_selected_system",  GA_Write | GA_NoSave, "" );

	// Global string for the selected system name.
	Global.CreateString( "g_lf_waypoint_system",  GA_Write | GA_NoSave, "" );

	// Global string for the selected system name.
	Global.CreateBool( "g_lf_screen_active",  GA_Write | GA_NoSave, false );


	// Key bindings
	// ************

	// Key binding for the location finder screen toggle.
	// Handily, the Multiplayer score binding is very useful indeed, and
	// ensures we don't have to create a custom binding just for this
	// key.
	Input.BindKey( "LocationFinder.LocationFinderToggle", "Multiplayer.Score" );
	
	// Key binding for the PDA manager, to remove the right hand shady bar.
	// when the PDA screen is accessed.
	Input.BindKey( "LocationFinder.OnPDA", "SpaceFlight.PDA" );

	// This adds the custom text for the location finder.
	Text.Add( "csv:/text/location_finder" );
}


// END OF CODE
// *********************************************************************************
